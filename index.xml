<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Welcome! | SÃ¼mer Cip</title><link>https://sumercip.com/</link><description>Recent content on Welcome! | SÃ¼mer Cip</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 30 Dec 2024 18:48:06 +0300</lastBuildDate><atom:link href="https://sumercip.com/index.xml" rel="self" type="application/rss+xml"/><item><title>May thy bits chip and shatter:&lt;br> Patterns for Building High-Performance Observability Pipelines at Scale</title><link>https://sumercip.com/posts/patterns-for-building-high-perf-observability-pipelines/</link><pubDate>Mon, 30 Dec 2024 18:48:06 +0300</pubDate><guid>https://sumercip.com/posts/patterns-for-building-high-perf-observability-pipelines/</guid><description>&lt;h1 id="motivation">Motivation&lt;/h1>
&lt;p>&lt;img src="https://sumercip.com/sandworm.png" alt="">&lt;/p>
&lt;p>As seen from the title, Iâ€™m a huge Dune fan. Much like &lt;a href="https://en.wikipedia.org/wiki/Sandworm_(Dune)">sandworms&lt;/a> lurking beneath the surface, ready to appear unexpectedly, the scale and complexity of observability data can be just as massive, unpredictable, and a little terrifying.&lt;/p>
&lt;blockquote>
&lt;p>â€œBut I do see a way. There is a narrow way through.â€&lt;/br>
&amp;ndash; Paul Muad&amp;rsquo;Dib Atreides, Dune Part Two&lt;/p>
&lt;/blockquote>
&lt;p>Sci-fi analogies aside, designing high-throughput observability data pipelines is a topic that fascinates me, with all the unique challenges it brings to database design and architecture. Itâ€™s a fascinating intersection of database design and architecture, packed with unique challenges.&lt;/p></description></item><item><title>In the Making of Python Fitter and Faster</title><link>https://sumercip.com/posts/making-python-fitter-and-faster/</link><pubDate>Fri, 04 Oct 2024 18:49:37 +0300</pubDate><guid>https://sumercip.com/posts/making-python-fitter-and-faster/</guid><description>&lt;h1 id="pythons-performance-revolution">Pythonâ€™s Performance Revolution&lt;/h1>
&lt;p>&lt;img src="https://sumercip.com/yess.png" alt="">&lt;/p>
&lt;p>Since Python 3.11, there has been a strong, ongoing effort to make Python faster, and the results are clear. Performance improvements are real, and the work continues.&lt;/p>
&lt;p>It&amp;rsquo;s both refreshing and surprising to see such significant speed gains in a language that&amp;rsquo;s nearly 30 years old.&lt;/p>
&lt;p>But make no mistake: there&amp;rsquo;s no magic here. In my humble opinion, the success can be attributed to a few key factors:&lt;/p></description></item><item><title>Articles</title><link>https://sumercip.com/articles/</link><pubDate>Sun, 31 Dec 2023 17:47:24 +0300</pubDate><guid>https://sumercip.com/articles/</guid><description>&lt;p>Here are some articles and blog posts mostly related to my work found at other sites:&lt;/p>
&lt;h1 id="2023">2023&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://upsun.com/blog/python-gevent-best-practices/">Gevent Best Practices&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://upsun.com/blog/making-our-project-API-faster-with-blackfire-profiler/">Making our API backend faster with Blackfire Profiler&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="2022">2022&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://blog.blackfire.io/the-challenges-of-async-python-observability-introduction-to-fastapi-and-asyncio-1-3.html">Challenges of Asynchronous Python profiling&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="2020">2020&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://blog.blackfire.io/profiling-101-for-python-developers-what-is-a-profiler-1-6.html">Profiling 101 for Python Developers&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.blackfire.io/python-memory-profiling-with-blackfire.html">Memory profiling with Python&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.blackfire.io/analyzing-python-profiles-with-the-blackfire-timeline.html">Blackfire Profiler - Timeline view&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Talks</title><link>https://sumercip.com/talks/</link><pubDate>Sun, 31 Dec 2023 17:47:24 +0300</pubDate><guid>https://sumercip.com/talks/</guid><description>&lt;p>Here are my recorded talks from various conferences mosly related to performance and observability:&lt;/p>
&lt;h1 id="2024">2024&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://kommunity.com/talks/go-ing-easy-on-memory-writing-gc-friendly-code-sumer-cip-33eaefcd/slide">GoKonf Istanbul 2024 - Go-ing Easy on Memory: Writing GC-friendly Code&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="2021">2021&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=1EZ8oqjLun0">PyCon US 2021 Sponsor Workshop - Debugging Performance - SÃ¼mer Cip &amp;amp; JÃ©rÃ´me Vieilledent&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=ZBJ30MAlc_0">DjangoCon EU 2021 - Hunting Python Performance&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=01z4hEaR4SE">DjancoCon 2021 WorkShop - Profiling Django &amp;amp; Python apps - SÃ¼mer Cip &amp;amp; JÃ©rÃ´me Vieilledent&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="2020">2020&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://tr.pycon.org/">PyCon Turkey 2020 - Hunting Performance in Python Code - (Video not available, but details can be seen here)&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Inside the Go CPU profiler</title><link>https://sumercip.com/posts/inside-the-go-cpu-profiler/</link><pubDate>Mon, 26 Sep 2022 18:42:25 +0300</pubDate><guid>https://sumercip.com/posts/inside-the-go-cpu-profiler/</guid><description>&lt;p>Go is one of its kind when it comes to profiling. It includes powerful and opinionated(!) profilers inside the runtime. Other languages like
Ruby, Python, or Node.js, contains profilers or a few APIs for writing profilers. But they are limited in scope compared to what Go offers out of the box. If you want to learn more about the types of observability tools that Go provides, I highly recommend Felix GeisendÃ¶rfer&amp;rsquo;s
&lt;a href="https://github.com/DataDog/go-profiler-notes/blob/main/guide/README.md">The Busy Developer&amp;rsquo;s Guide to Go Profiling, Tracing and Observability&lt;/a>&lt;/p></description></item><item><title>About</title><link>https://sumercip.com/about/</link><pubDate>Fri, 31 Dec 2021 17:47:24 +0300</pubDate><guid>https://sumercip.com/about/</guid><description>&lt;p>Hey ðŸ˜ƒ,&lt;/p>
&lt;p>My name is SÃ¼mer Cip. I have been coding roughly my whole life and have worked for various companies in different Software Engineering roles. Visit my &lt;a href="https://www.linkedin.com/in/sumer-cip/">LinkedIn profile&lt;/a> for more information. I have tried my best to contribute to various Open Source projects whenever possible, most notably &lt;a href="https://github.com/sumerc/yappi">Yappi&lt;/a>. I have always been passionate about developing tools to simplify/optimize systems. These days, I am mainly interested in &lt;b>Observability&lt;/b>, &lt;b>Distributed Systems&lt;/b>, &lt;b>Database internals&lt;/b>, &lt;b>Low-level security&lt;/b>, &lt;b>Go&lt;/b> and &lt;b>Python&lt;/b>.&lt;/p></description></item><item><title>Improve zsh startup time via lazyload</title><link>https://sumercip.com/posts/lazyload-zsh/</link><pubDate>Fri, 31 Dec 2021 11:29:57 +0300</pubDate><guid>https://sumercip.com/posts/lazyload-zsh/</guid><description>&lt;h1 id="my-shell-is-slooow">My shell is slooow!&lt;/h1>
&lt;p>This is my first blog post for years. I have been finding excuses for not writing one over
the years, but I feel this is the right time.&lt;/p>
&lt;p>I was coding as usual when I started something odd with my shell. I have done few adjustments
to my &lt;code>.zshrc&lt;/code> file and out of a sudden it became very slow to spawn a new shell. As a person
who has a obsession with performance, it became my duty to find out the problem.&lt;/p></description></item></channel></rss>