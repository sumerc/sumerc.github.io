<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.155.3"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="map[homepage:https://sumercip.com/ name:Sümer Cip]"><meta property="og:url" content="https://sumercip.com/posts/inside-the-go-cpu-profiler/"><link rel=canonical href=https://sumercip.com/posts/inside-the-go-cpu-profiler/><link rel=apple-touch-icon href=/images/favico.svg><link rel=icon type=image/svg+xml href=/images/favico.svg><link rel=shortcut href=/images/favico.svg><link rel=alternate type=application/atom+xml href=https://sumercip.com/index.xml title="Welcome! | Sümer Cip"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/sumercip.com\/"},"articleSection":"posts","name":"Inside the Go CPU profiler","headline":"Inside the Go CPU profiler","description":"How does the Go CPU profiler works under the hood?","inLanguage":"en-US","author":"Sümer Cip","creator":"Sümer Cip","publisher":"Sümer Cip","accountablePerson":"Sümer Cip","copyrightHolder":"Sümer Cip","copyrightYear":"2022","datePublished":"2022-09-26 18:42:25 \u002b0300 \u002b0300","dateModified":"2022-09-26 18:42:25 \u002b0300 \u002b0300","url":"https:\/\/sumercip.com\/posts\/inside-the-go-cpu-profiler\/","keywords":["go","profiling","cpu"]}</script><title>Inside the Go CPU profiler</title><meta property="og:title" content="Inside the Go CPU profiler"><meta property="og:type" content="article"><meta property="og:description" content="How does the Go CPU profiler works under the hood?"><meta name=description content="How does the Go CPU profiler works under the hood?"><meta property="og:locale" content="en-us"><style>.row{display:flex;flex-wrap:wrap}.col-xs-2{flex:0 0 16.6667%;max-width:16.6667%}.col-xs-3{flex:0 0 25%;max-width:25%}.col-xs-6{flex:0 0 50%;max-width:50%}.col-xs-10{flex:0 0 83.3333%;max-width:83.3333%}.col-xs-12{flex:0 0 100%;max-width:100%}.col-xs-offset-9{margin-left:75%}.center-xs{justify-content:center}.middle-xs{align-items:center}.end-xs{justify-content:flex-end}@media(min-width:64em){.end-md{justify-content:flex-end}}body{font-family:inter,sans-serif;line-height:1.5;-webkit-font-smoothing:antialiased;margin:0 20px;background-color:#fed6a1;background-size:40px 40px;background-position:-19px -19px}h1{font-size:1.5em}h1,h2,h3,h4,h5,h6{font-family:inter,sans-serif}blockquote{margin-block-start:0;margin-block-end:0;margin-inline-start:0;margin-inline-end:0;border-left:5px solid #747474;padding-left:20px;color:#555;font-family:Source Serif Pro,serif;font-size:1.1em;background:#fdf2e6;padding-top:1px;padding-bottom:1px;padding-right:10px}strong{font-weight:600}ol{padding-inline-start:20px}ul{padding-inline-start:40px}article{max-width:680px;margin-left:auto;margin-right:auto}a{color:#000;text-decoration:none}a:hover{text-decoration:underline;color:#f41d92}.progress-indicator{position:fixed;top:0;width:100%;z-index:10;height:5px;background-color:#f41d92}.post-ads{margin:50px 0}.markdown-body{font-size:1.1em;max-width:100%}.markdown-body a{text-decoration:underline}.markdown-body pre{overflow:auto;border-radius:1px;padding:20px;box-shadow:6px 6px rgba(0,0,0,.1);border:1px solid rgba(0,0,0,5%);margin:0;line-height:normal}.markdown-body code{display:inline-block;font-size:.8em;font-family:geist mono,monospace;margin-bottom:2px;border-radius:4px}.markdown-body a code{text-decoration:underline;color:inherit}.markdown-body pre>code{padding:0;font-size:80%;background-color:inherit;border:0}.site-date-catalog{font-size:2rem}.header-title{font-size:1.3rem;font-weight:700;margin-top:32px;font-family:inter,sans-serif}.logo__cursor{display:inline-block;width:10px;height:1rem;background:#f41d92;border-radius:1px;animation:cursor 1s infinite}@keyframes cursor{0%{opacity:0}50%{opacity:1}to{opacity:0}}.header-title a{text-decoration:none}.header-subtitle{color:#747474;font-size:1.1em}.header-items{margin:10px 0}.header-item{margin:0 5px;font-weight:600;font-family:Inter}.header-line{width:100%;border-width:1px;border-color:#482936;border-style:solid none none none}.lang-switch{font-weight:600}#posts-list{min-height:600px}.posts-date{color:#747474;font-weight:400;font-size:1rem;letter-spacing:.08em}.posts-title{font-size:1.2rem;font-weight:600;font-family:inter}.posts-title-row{display:flex;justify-content:space-between;align-items:center}.post-icons{white-space:nowrap;margin-left:12px}.post-icons i{margin-left:6px;color:#fed6a1;font-size:1.2em;background-color:#000;border:none;border-radius:8px;width:1.4em;height:1.4em;display:inline-flex;align-items:center;justify-content:center;cursor:pointer;transition:background-color .2s,color .2s,border-color .2s}.post-icons i:hover{background-color:#f41d92;color:#fff}.posts-line{font-size:1.2rem;margin:20px 0}.site-footer{margin-top:50px}.post-content img{max-width:100%;display:block;margin:0 auto}.post-header{margin-bottom:50px}.post-title{font-size:1.8rem;font-weight:900;margin-block-start:0;margin-block-end:0}.post-tags{display:inline;font-weight:600;padding:2px 5px;margin-right:6px;border:#000 2px solid;border-radius:5px}.post-date{font-weight:800;font-style:italic}hr{margin:2em 0;border:0}hr:after{content:"...";text-align:center;display:block;letter-spacing:.6em;font-size:1.1em}.page-content{min-height:60%}.post-content p{hyphens:auto;text-justify:ideographic;margin-bottom:1.1em}.related-content{border-width:3px;border-style:solid;border-color:#000;padding:0 10px;margin-bottom:50px;margin-top:100px}.related-content li{margin:5px 0}.taxonomy-term{font-size:3rem}.gallery-img{text-align:center}.gallery-img span{text-align:center}.gallery-img-desc{font-size:.8em;font-weight:800}#disqus_thread{position:relative}#disqus_thread:after{content:"";display:block;height:55px;width:100%;position:absolute;bottom:0;background:#fff}@media screen and (max-width:600px){.header-subtitle,.header-items{text-align:center}.posts-line{font-size:1.1em}.markdown-body{font-size:1.1em}.post-title{font-size:2em}}.chroma{background-color:#fdf2e6}.chroma .err{color:#a61717;background-color:#e3d2d2}.chroma .lntd{vertical-align:top;padding:0;margin:0;border:0}.chroma .lntable{border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:hidden;display:block}.chroma .hl{display:block;width:100%;background-color:#fafa64}.chroma .lnt,.chroma .ln{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .k,.chroma .kc,.chroma .kd,.chroma .kn,.chroma .kp,.chroma .kr,.chroma .o,.chroma .ow{color:#000;font-weight:700}.chroma .kt,.chroma .nc{color:#458;font-weight:700}.chroma .na,.chroma .no,.chroma .nv,.chroma .vc,.chroma .vg,.chroma .vi{color:teal}.chroma .nb{color:#0086b3}.chroma .bp{color:#999}.chroma .nd{color:#3c5d5d;font-weight:700}.chroma .ni{color:purple}.chroma .ne,.chroma .nf,.chroma .nl{color:#900;font-weight:700}.chroma .nn,.chroma .gp{color:#555}.chroma .nt{color:navy}.chroma .s,.chroma .sa,.chroma .sb,.chroma .sc,.chroma .dl,.chroma .sd,.chroma .s2,.chroma .se,.chroma .sh,.chroma .si,.chroma .sx,.chroma .s1{color:#d14}.chroma .sr{color:#009926}.chroma .ss{color:#990073}.chroma .m,.chroma .mb,.chroma .mf,.chroma .mh,.chroma .mi,.chroma .il,.chroma .mo{color:#099}.chroma .c,.chroma .ch,.chroma .cm,.chroma .c1{color:#998;font-style:italic}.chroma .cs,.chroma .cp,.chroma .cpf{color:#999;font-weight:700;font-style:italic}.chroma .gd{color:#000;background-color:#fdd}.chroma .ge{color:#000;font-style:italic}.chroma .gr,.chroma .gt{color:#a00}.chroma .gh{color:#999}.chroma .gi{color:#000;background-color:#dfd}.chroma .go{color:#888}.chroma .gs{font-weight:700}.chroma .gu{color:#aaa}.chroma .gl{text-decoration:underline}.chroma .w{color:#bbb}details.toc-container summary{padding:.5em;font-weight:700;cursor:pointer;background:lightgrey;font-family:Inter}details.toc-container{border:1px solid var(--stable-color);background-color:#fdf2e6;box-shadow:6px 6px rgba(0,0,0,.15)}.toc{padding:.5em}.toc a{display:block;text-decoration:underline;font-size:1.1em}details[open]>summary:first-of-type{list-style-type:disclosure-open}details>summary:first-of-type{list-style:inside disclosure-closed}h2.post-desc{margin:unset;color:#747474;font-size:1.2em;font-weight:400;margin-top:10px}h1.post-title{line-height:1.3;margin-top:10px;font-family:Inter;font-weight:700}.citation{position:relative;cursor:pointer;color:#5e1fff;padding-bottom:10px;font-size:75%;vertical-align:super}.citation-tooltip{position:absolute;top:calc(100%);left:-10px;border:1px solid #000;padding:15px;border-radius:8px;box-shadow:rgba(28,14,64,.15)0 .125rem .5rem;visibility:hidden;opacity:0;transition:visibility 0s,opacity .3s ease;z-index:10;max-width:316px;width:316px;word-wrap:break-word;color:#333;background-color:#fdf2e6}.citation:hover .citation-tooltip,.citation-tooltip:hover,.citation:focus-within .citation-tooltip{visibility:visible;opacity:1}.citation-tooltip::after{content:"";position:absolute;top:-13px;left:5%;transform:translateX(-50%);border-width:7px;border-style:solid;border-color:transparent transparent #fdf2e6 transparent}.citation-tooltip::before{content:"";position:absolute;top:-16px;left:5%;transform:translateX(-50%);border-width:8px;border-style:solid;border-color:transparent transparent #000 transparent}.citation-tooltip::before,.citation-tooltip::after{pointer-events:none}.citation:hover,.citation-tooltip:hover{outline:none}</style><link rel=dns-prefetch href=https://www.googletagmanager.com><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&family=Geist+Mono:wght@400&family=Source+Serif+Pro&display=swap" onload='this.onload=null,this.rel="stylesheet"'><link rel=preload as=style href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&family=Geist+Mono:wght@400&family=Source+Serif+Pro&display=swap"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css></noscript></head><body><article class=post id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class=header-title><a href=/>Sümer Cip</a>
<span class=logo__cursor></span>
<a href=/index.xml target=_blank style=float:right><i class="fas fa-rss"></i>
</a><a href=https://twitter.com/sumercip target=_blank style=float:right;margin-right:8px><i class="fab fa-twitter"></i>
</a><a href=https://github.com/sumerc target=_blank style=float:right;margin-right:8px><i class="fab fa-github"></i></a></div><div class=header-subtitle>My notes on random stuff about tech</div></header><div class="row end-md center-xs header-items"><div class=header-item><a href=/>Home</a></div><div class=header-item><a href=/articles>Articles</a></div><div class=header-item><a href=/talks>Talks</a></div><div class=header-item><a href=/about>About</a></div></div><div class=header-line></div><script async src="https://www.googletagmanager.com/gtag/js?id=UA-154918616-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-154918616-1")</script></div><header class=post-header></br><div class="row post-desc"><div class=col-xs-12><time class=posts-date datetime="26 Sep 2022">26 Sep 2022 · 8 min read</time></div></div><h1 class=post-title>Inside the Go CPU profiler</h1><h2 class=post-desc>How does the Go CPU profiler works under the hood?</h2></header><details class=toc-container open><summary>Table of Contents</summary><div class=toc><ul><li><a href=#basics>Basics</a></li><li><a href=#a-small-survey-on-how-other-profilers-work>A small survey on how other profilers work</a></li><li><a href=#how-the-profiler-is-triggered-periodically>How the profiler is triggered periodically?</a></li><li><a href=#how-profiler-collects-data>How profiler collects data?</a></li><li><a href=#overhead>Overhead</a></li><li><a href=#conclusion>Conclusion</a></li></ul></div></details><hr></hr><div class="post-content markdown-body" data-progress-indicator><p>Go is one of its kind when it comes to profiling. It includes powerful and opinionated(!) profilers inside the runtime. Other languages like
Ruby, Python, or Node.js, contains profilers or a few APIs for writing profilers. But they are limited in scope compared to what Go offers out of the box. If you want to learn more about the types of observability tools that Go provides, I highly recommend Felix Geisendörfer&rsquo;s
<a href=https://github.com/DataDog/go-profiler-notes/blob/main/guide/README.md>The Busy Developer&rsquo;s Guide to Go Profiling, Tracing and Observability</a></p><p>As a curious engineer, I love to dig deep into how things work at a lower level, and I have always wanted to teach
myself how the Go CPU profiler works under the hood. This blog post is the result of that journey. I always find myself learning new things when I read Go runtime, and this was no exception.</p><h1 id=basics>Basics</h1><p>There are two types of profilers:</p><ul><li><strong>tracing</strong>: do measurements whenever a pre-defined event happens. e.g., function called, function exited&mldr;etc.</li><li><strong>sampling</strong>: do measurements at regular intervals.</li></ul><p>Go CPU profiler is a sampling profiler. There is also a <a href=https://pkg.go.dev/runtime/trace>Go execution tracer</a> which is
tracing profiler and traces certain events like acquiring a Lock, GC-related events&mldr;etc.</p><p>Sampling profilers usually consist of two essential parts:</p><ul><li><strong>sampler</strong>: a callback is called at regular intervals, and a stack trace is usually collected by profiling data. Different profilers use different strategies to trigger the callback.</li><li><strong>data collection</strong>: this is where the profiler collects its data: it might be memory consumption or call count, basically any metric associated with a stack trace.</li></ul><h1 id=a-small-survey-on-how-other-profilers-work>A small survey on how other profilers work</h1><p><strong>Linux perf</strong> uses PMU(Performance Monitor Unit) counters for sampling. You instruct the PMU to generate an interrupt after some event happens N times. An example might be to tick in every 1000 CPU clock cycles. A <a href=https://easyperf.net/blog/2018/06/01/PMU-counters-and-profiling-basics>detailed article</a> written by Denis Bakhvalov explains how tools like Linux perf and VTune use PMU counters to make this happen. Once the data collection callback is triggered at regular intervals, all is left to collect stack traces and aggregate them properly. To be complete, Linux perf uses <code>perf_event_open(PERF_SAMPLE_STACK_USER, ...)</code> to obtain stack trace information. The captured stack traces are written to userspace via mmap&rsquo;d ring buffer.</p><p><a href=https://github.com/benfred/py-spy>pyspy</a> and <a href=https://github.com/rbspy/rbspy>rbspy</a> are famous sampling profilers for Python and Ruby. They both ran as external processes and periodically read the target application memory to capture the stack trace of running threads. In Linux, they use <code>process_vm_readv</code>, and if I am not mistaken, this API pauses the target application for a few milliseconds during memory read. Then they chase pointers inside the memory they read to find the currently running thread structure and stack trace information. As one might guess, this is an error-prone and complex approach but works surprisingly well. <a href=https://github.com/uber-archive/pyflame>pyflame</a> uses a similar approach too.</p><p>Recent profilers like <a href=parca.dev>Parca</a>(there are few others) use <a href=https://ebpf.io/><strong>eBPF</strong></a>. eBPF is a recent technology that allows to run userland code in the Kernel VM. It is a brilliant technology that is used in lots of areas like security, networking, and observability. I highly suggest reading some information on eBPF; it is a massive topic that goes well beyond the scope of this blog post.</p><h1 id=how-the-profiler-is-triggered-periodically>How the profiler is triggered periodically?</h1><p>Go CPU profiler is a sampling profiler. In Linux, Go runtime uses <code>setitimer</code>/<code>timer_create/timer_settime</code> APIs to set up a <code>SIGPROF</code> signal handler. This handler is triggered at periodic intervals controlled by <code>runtime.SetCPUProfileRate</code>, which is 100Mz(10ms) by default. As a side note: surprisingly, there were some serious issues around the sampler of the Go CPU profiler until Go 1.18! You can see the gory details on these problems <a href=https://www.datadoghq.com/blog/engineering/profiling-improvements-in-go-1-18/>here</a>. The <code>setitimer</code> API was the recommended way of triggering time-based signals per-thread in Linux, <del>but it was not working as advertised. Please feel free to correct me if this claim is wrong.</del> <em>(Felix Geisendörfer corrected this <a href=https://twitter.com/felixge/status/1574712785631682560>claim</a>)</em>: Technically it works as you&rsquo;d expect from a process-directed signal mechanism. But it&rsquo;s not a good mechanism for multicore profiling.</p><p>Let&rsquo;s see how you can enable the Go CPU profiler manually:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>f</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>os</span><span class=p>.</span><span class=nf>Create</span><span class=p>(</span><span class=s>&#34;profile.pb.gz&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>pprof</span><span class=p>.</span><span class=nf>StartCPUProfile</span><span class=p>(</span><span class=nx>f</span><span class=p>);</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>defer</span><span class=w> </span><span class=nx>pprof</span><span class=p>.</span><span class=nf>StopCPUProfile</span><span class=p>()</span><span class=w>
</span></span></span></code></pre></div><p>Once <code>pprof.StartCPUProfile</code> is called, Go runtime enables the <code>SIGPROF</code> signal to be generated at specific intervals. The kernel sends the signal signal to one of the <em>running</em> threads in the application. Since Go uses non-blocking I/O, goroutines waiting on I/O are not counted as <em>running</em>, and the Go CPU Profiler does not catch these. As a side note: this was the basic reason why <a href=https://github.com/felixge/fgprof>fgprof</a> was implemented. fgprof uses <a href=https://pkg.go.dev/runtime#GoroutineProfile><code>runtime.GoroutineProfile</code></a> to obtain both on and off-CPU goroutines.</p><p>A picture is worth a thousand words; below is how Go runtime handles <code>SIGPROF</code> signal:</p><p><img src=/sigprof.png alt="SIGPROF signal in the Go runtime"></p><h1 id=how-profiler-collects-data>How profiler collects data?</h1><p>Once, a random running goroutine receives a <code>SIGPROF</code> signal, it gets interrupted and signal handler runs. The stack trace of the interrupted goroutine is retrieved in the context of this signal handler and then saved into a <a href=https://preshing.com/20120612/an-introduction-to-lock-free-programming/>lock-free</a> log structure along with the current <a href=https://rakyll.org/profiler-labels/>profiler label</a>(Every captured stack trace can be associated with a custom label which you can later do filtering on). This special lock-free structure is named as <code>profBuf</code> and it is defined in <a href=https://github.com/golang/go/blob/master/src/runtime/profbuf.go>runtime/profbuf.go</a> with a long and detailed explanation on how it works. It is a <em>single-writer, single-reader</em> lock-free <a href=https://en.wikipedia.org/wiki/Circular_buffer>ring-buffer</a> structure which resembles the one published <a href=http://www.cse.cuhk.edu.hk/~pclee/www/pubs/ancs09poster.pdf>here</a>. The writer is the profiler signal handler and the reader is a goroutine(<code>profileWriter</code>) that periodically reads this buffer and aggregates results to a final hashmap. This final hashmap structure is named as <code>profMap</code> and defined in <a href=https://github.com/golang/go/blob/master/src/runtime/pprof/map.go>runtime/pprof/map.go</a></p><p>Here is a simple visualization on how this all fits together:</p><p><img src=/sigprof_handler.png alt="SIGPROF handler"></p><p>As can be seen, the final structure resembles the regular <code>pprof.Profile</code> object a lot: it is a a hashmap where the key is stack trace + label and the value is the number of times where this callstack is observed in the application. When <code>pprof.StopCPUProfile</code> is called, profiling stops and <a href=https://github.com/golang/go/blob/aa4299735b78189eeac1e2c4edafb9d014cc62d7/src/runtime/pprof/proto.go#L348><code>profileWriter.build</code></a> gets called. This function is responsible for writing this <code>profMap</code> structure to the <code>io.Writer</code> object that is provided in the initial <code>pprof.StartCPUProfile</code> call. This is where the final <a href=https://pkg.go.dev/runtime/pprof#Profile><code>pprof.Profile</code></a> object is generated.</p><p>Pseudocode for <code>profileWriter</code> might be helpful here:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>profileWriter</span><span class=p>(</span><span class=nx>w</span><span class=w> </span><span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>100</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>data</span><span class=p>,</span><span class=w> </span><span class=nx>tags</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>readProfile</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>e</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nf>addCPUData</span><span class=p>(</span><span class=nx>data</span><span class=p>,</span><span class=w> </span><span class=nx>tags</span><span class=p>);</span><span class=w> </span><span class=nx>e</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=o>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>profilerStopped</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>break</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>b</span><span class=p>.</span><span class=nf>build</span><span class=p>()</span><span class=w> </span><span class=c1>// -&gt; generates final pprof.Profile</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Why Go took all the trouble for implementing a unique lock-free structure just for holding temporary profiling data? Why not write everything to a hashmap periodically?</p><p>Look at the first thing that the <code>SIGPROF</code> handler does is to disable memory allocation. Additionally, the profiler code path does not involve any locks and even the maximum depth of stack trace is hardcoded. As of Go 1.19, it is <a href=https://github.com/golang/go/blob/54cf1b107d24e135990314b56b02264dba8620fc/src/runtime/cpuprof.go#L22>64</a>. All these details are there to provide a more efficient and predictable overhead for the profiler. Low and predictable performance is key for a production-ready profiler.</p><h1 id=overhead>Overhead</h1><p>Based on the design, should the profiler overhead be constant? Well, it depends. Let me explain why: in a single profiler interrupt, the following happens:</p><ol><li>a random running goroutine context switch to run the <code>SIGPROF</code> handler code,</li><li>stack walk happens, and Go runtime saves the stack trace to a lock-free ring buffer,</li><li>the goroutine is resumed.</li></ol><p>In theory, it seems like all above should run in constant time as no allocation and locks are happening. <del>While I could not find the reference, I remember all the</del> And this is true: all above happens in around ~~~10 nanoseconds~~ ~1 microseconds (on a typical CPU)<em>(<a href=https://twitter.com/felixge/status/1574762438225960960>Corrected</a> by Felix Geisendörfer)</em>. But, in practice, it becomes much worse. If you search for the &ldquo;overhead of the Go CPU profiler&rdquo;, you will see numbers ranging from <a href=https://cloud.google.com/blog/products/management-tools/in-tests-cloud-profiler-adds-negligible-overhead>%0.5</a> to <a href=https://medium.com/google-cloud/continuous-profiling-of-go-programs-96d4416af77b>%1-%5</a> <del>and even %10</del><em>(no public mention was found on this number and no emprirical evidence, too)</em>. The reason behind this is mostly related to how CPUs work. Modern CPUs are complex beasts. They cache aggressively. A typical single CPU core has three layers of cache: L1, L2, and L3. When a specific CPU-intensive code is running, these caches are highly utilized. High cache utilization is especially true for some applications where small(data that can fit in cache) and sequential data is read heavily.</p><p>An excellent example of this is matrix multiplication: during matrix multiplication, CPU heavily accesses individual cells which are sequential in memory. These kinds of cache-friendly applications might produce <em>worst</em> overhead for a sampling profiler. While it is tempting to do some benchmarks with <code>perf</code> to verify this claim, it is beyond the scope of this blog post.</p><p>Having said the above, Go runtime has done a great job of keeping the profiler overhead as predictable and as low as possible. If you don&rsquo;t believe me, which you should not, maybe below quote from a discussion <a href=https://groups.google.com/g/golang-nuts/c/e6lB8ENbIw8/m/azeTCGj7AgAJ>thread</a> can convince you:</p><blockquote><p>At Google, we continuously profile Go production services, and it is safe to do so.</p></blockquote><p>And another one is from a <a href=https://github.com/DataDog/dd-trace-go/commit/54604a13335b9c5e4ac18a898e4d5971b6b6fc8c>commit</a> from DataDog&rsquo;s continuous profiler implementation to make the profiler <em>always be enabled</em>:</p><blockquote><p>After testing this default on many high-volume internal workloads, we&rsquo;ve
determined this default is safe for production.</p></blockquote><p>And as a final note, based on the above theory, we can make following observation:</p><p>The profiler overhead will be minimum on typical I/O bound applications.</p><p>This is because CPU cache trashing does not make much difference when there are many sleeping/idle goroutines. We have observed this over and over during our Go CPU profiler benchmarks&ndash; there is literally <em>zero</em> (or statistically insignificant) overhead on typical I/O bound applications. Providing empirical evidence is beyond the scope of this blog post. One way to do it might be to observe the throughput during load testing with the profiler on and off.</p><h1 id=conclusion>Conclusion</h1><p>One aspect I admire about this design is how it showcases the power of optimization when you deeply understand the access patterns of your underlying data structures. For instance, the Go runtime leverages a lock-free structure, which might seem like overkill for most situations. Yet, this choice reflects the depth of thought behind Go’s performance strategies. The runtime is filled with similar clever optimizations, and I highly recommend exploring the parts that capture your interest.</p><h1 id=references>References</h1><ol><li><a href=https://github.com/DataDog/go-profiler-notes/blob/main/guide/README.md>https://github.com/DataDog/go-profiler-notes/blob/main/guide/README.md</a></li><li><a href=https://easyperf.net/blog/2018/06/01/PMU-counters-and-profiling-basics>https://easyperf.net/blog/2018/06/01/PMU-counters-and-profiling-basics</a></li><li><a href=https://www.instana.com/blog/go-profiler-internals/>https://www.instana.com/blog/go-profiler-internals/</a></li><li><a href=https://www.datadoghq.com/blog/engineering/profiling-improvements-in-go-1-18/>https://www.datadoghq.com/blog/engineering/profiling-improvements-in-go-1-18/</a></li><li><a href=http://www.cse.cuhk.edu.hk/~pclee/www/pubs/ancs09poster.pdf>http://www.cse.cuhk.edu.hk/~pclee/www/pubs/ancs09poster.pdf</a></li><li><a href=https://easyperf.net/blog/2018/06/01/PMU-counters-and-profiling-basics>https://easyperf.net/blog/2018/06/01/PMU-counters-and-profiling-basics</a></li></ol></div><div class="row middle-xs"><div class=col-xs-12><div class=post-tags><a href=/tags/go/>go</a></div><div class=post-tags><a href=/tags/profiling/>profiling</a></div><div class=post-tags><a href=/tags/cpu/>cpu</a></div></div></div><div class=row><div class=col-xs-12></div></div><div class=site-footer align=center><hr></hr></div></div></div></article><script>(function(e,t){const o=t.querySelector("[data-progress-indicator]");if(!o)return;const n=t.createElement("div");n.classList.add("progress-indicator"),n.style.left="-100%",n.style.transform="translateX(-100%)",t.body.appendChild(n);let i=0,s=!1;e.addEventListener("scroll",function(){if(i=e.scrollY,s)return;e.requestAnimationFrame(function(){var t=Math.min(100,i/(o.scrollHeight-e.innerHeight)*100);n.style.transform=`translateX(${t}%)`,s=!1}),s=!0})})(window,document)</script></body></html>